'use strict';

import { GW_ERROR_NTF, Scene, Scenes, GW_GET_SCENE_LIST_NTF, GW_GET_SCENE_LIST_CFM, GW_GET_SCENE_INFORMATION_NTF, GW_GET_SCENE_INFORMATION_CFM, GW_SCENE_INFORMATION_CHANGED_NTF, GW_ACTIVATE_SCENE_CFM, GW_SESSION_FINISHED_NTF, GW_STOP_SCENE_CFM, GW_GET_ALL_NODES_INFORMATION_CFM, GW_GET_ALL_NODES_INFORMATION_NTF, GW_GET_ALL_NODES_INFORMATION_FINISHED_NTF, Products, Product, GW_GET_NODE_INFORMATION_CFM, GW_GET_NODE_INFORMATION_NTF, GW_CS_SYSTEM_TABLE_UPDATE_NTF } from "../src";
import { expect, use } from "chai";
import chaiAsPromised from "chai-as-promised";
import { MockConnection } from "./mocks/mockConnection";
import sinon from "sinon";

use(chaiAsPromised);


describe("products", function() {
    describe("Products class", function () {
        // Error frame
        const dataError = Buffer.from([0x04, 0x00, 0x00, 0x07]);
        const dataErrorNtf = new GW_ERROR_NTF(dataError);

        // Frames for products list
        const dataAllNodes = Buffer.from([0x05, 0x02, 0x03, 0x00, 0x05]);
        const dataAllNodesCfm = new GW_GET_ALL_NODES_INFORMATION_CFM(dataAllNodes);

        const dataNodes = [
            Buffer.from([0x7f, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x46, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x20, 0x42, 0x61, 0x64, 0x65, 0x7a, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0xd5, 0x07, 0x00, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xc8, 0x00, 0xc8, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x3f, 0xf3, 0x01, 0xd8, 0x03, 0xb2, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            Buffer.from([0x7f, 0x02, 0x04, 0x01, 0x00, 0x01, 0x02, 0x46, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x20, 0x53, 0x63, 0x68, 0x6c, 0x61, 0x66, 0x7a, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xd5, 0x07, 0x00, 0x01, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xc8, 0x00, 0xc8, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x3f, 0xf3, 0x02, 0xd8, 0x02, 0x64, 0x00, 0xd8, 0x03, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            Buffer.from([0x7f, 0x02, 0x04, 0x02, 0x00, 0x02, 0x03, 0x46, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x20, 0x41, 0x6e, 0x6b, 0x6c, 0x65, 0x69, 0x64, 0x65, 0x7a, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xd5, 0x07, 0x00, 0x01, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xc8, 0x00, 0xc8, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x3f, 0xf3, 0x02, 0xd8, 0x02, 0x64, 0x00, 0xd8, 0x03, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            Buffer.from([0x7f, 0x02, 0x04, 0x03, 0x00, 0x03, 0x02, 0x52, 0x6f, 0x6c, 0x6c, 0x6c, 0x61, 0x64, 0x65, 0x6e, 0x20, 0x53, 0x63, 0x68, 0x6c, 0x61, 0x66, 0x7a, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 0xd5, 0x05, 0x00, 0x01, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xc8, 0x00, 0xc8, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x3f, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
            Buffer.from([0x7f, 0x02, 0x04, 0x04, 0x00, 0x04, 0x04, 0x46, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x20, 0x42, 0xc3, 0xbc, 0x72, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xd5, 0x07, 0x00, 0x01, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xc8, 0x00, 0xc8, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x3f, 0xf3, 0x02, 0xd8, 0x02, 0x64, 0x00, 0xd8, 0x03, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
        ];
        const dataNodesNtf: GW_GET_ALL_NODES_INFORMATION_NTF[] = [];
        dataNodes.forEach(dataNode => {
            dataNodesNtf.push(new GW_GET_ALL_NODES_INFORMATION_NTF(dataNode));
        });
        const dataNodeFinish = Buffer.from([0x03, 0x02, 0x05]);
        const dataNodeFinishNtf = new GW_GET_ALL_NODES_INFORMATION_FINISHED_NTF(dataNodeFinish);

        const receivedFrames = [
            dataAllNodesCfm
        ];

        describe("createProductsAsync", function() {
            it("should create without error with 5 products.", async function() {
                const conn = new MockConnection(receivedFrames);
                const promResult = Products.createProductsAsync(conn);
                // Send nodes
                for (const dataNodeNtf of dataNodesNtf) {
                    conn.sendNotification(dataNodeNtf, []);
                }
                // Send finished
                conn.sendNotification(dataNodeFinishNtf, []);
                const result = await promResult;
                expect(result).to.be.instanceOf(Products);
                expect(result.Products.length).to.be.equal(5);
            });

            it("should throw an error on invalid frames.", async function() {
                const conn = new MockConnection([]);
                return expect(Products.createProductsAsync(conn)).to.rejectedWith(Error);
            });
        });
        
        describe("findByName", function() {
            it("should find product 'Fenster Badezimmer'.", async function() {
                const conn = new MockConnection(receivedFrames);
                const promProducts = Products.createProductsAsync(conn);
                // Send nodes
                for (const dataNodeNtf of dataNodesNtf) {
                    conn.sendNotification(dataNodeNtf, []);
                }
                // Send finished
                conn.sendNotification(dataNodeFinishNtf, []);
                const products = await promProducts;
                const result = products.findByName("Fenster Badezimmer");
                expect(result).to.be.instanceOf(Product).with.property("Name", "Fenster Badezimmer");
            });
        });
        
        describe("onNotificationHandler", function() {
            it("should add 1 product and remove 2 products.", async function() {
                const data = Buffer.from([55, 0x01, 0x12, 
                    // Added nodes (0)
                    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    // Removed nodes (0, 1)
                    3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                ]);
                const dataNtf = new GW_CS_SYSTEM_TABLE_UPDATE_NTF(data);
                const dataNodeInformation = Buffer.from([0x05, 0x02, 0x01, 0x00, 0x00]);
                const dataNodeInformationCfm = new GW_GET_NODE_INFORMATION_CFM(dataNodeInformation);
                const dataNodeInfoNotification = Buffer.from([0x7f, 0x02, 0x10, 0x00, 0x00, 0x00, 0x01, 0x46, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x20, 0x42, 0x61, 0x64, 0x65, 0x7a, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0xd5, 0x07, 0x00, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x66, 0x00, 0x66, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x4c, 0x93, 0x01, 0xd8, 0x03, 0xb2, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
                const dataNodeInfoNotificationNtf = new GW_GET_NODE_INFORMATION_NTF(dataNodeInfoNotification);

                const conn = new MockConnection(receivedFrames);
                const promProducts = Products.createProductsAsync(conn);
                for (const dataNodeNtf of dataNodesNtf) {
                    conn.sendNotification(dataNodeNtf, []);
                }
                // Send finished
                conn.sendNotification(dataNodeFinishNtf, []);
                const products = await promProducts;

                // Setups spies for counting notifications
                const productAddedSpy = sinon.spy();
                const productRemovedSpy = sinon.spy();
                products.onNewProduct((productID) => {
                    productAddedSpy(productID);
                });
                products.onRemovedProduct((productID) => {
                    productRemovedSpy(productID);
                });

                conn.sendNotification(dataNtf, [dataNodeInformationCfm]);
                conn.sendNotification(dataNodeInfoNotificationNtf, []);

                // Just let the asynchronous stuff run before our checks
                await new Promise(resolve => { setTimeout(resolve, 0); });

                expect(productAddedSpy.calledOnce, `onNewProduct should be called once. Instead it was called ${productAddedSpy.callCount} times.`).to.be.true;
                expect(productRemovedSpy.calledTwice, `onRemovedProduct should be called twice. Instead it was called ${productRemovedSpy.callCount} times.`).to.be.true;
            });
        });
        
        describe("addNodeAsync", function() {
            it("should throw on error frame.", async function() {
                const data = Buffer.from([55, 0x01, 0x12, 
                    // Added nodes (0)
                    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    // Removed nodes (0, 1)
                    3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                ]);
                const dataNtf = new GW_CS_SYSTEM_TABLE_UPDATE_NTF(data);
                const dataNodeInformation = Buffer.from([0x05, 0x02, 0x01, 0x00, 0x00]);
                const dataNodeInformationCfm = new GW_GET_NODE_INFORMATION_CFM(dataNodeInformation);
                const dataNodeInfoNotification = Buffer.from([0x7f, 0x02, 0x10, 0x00, 0x00, 0x00, 0x01, 0x46, 0x65, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x20, 0x42, 0x61, 0x64, 0x65, 0x7a, 0x69, 0x6d, 0x6d, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0xd5, 0x07, 0x00, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x66, 0x00, 0x66, 0x00, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x4f, 0x00, 0x4c, 0x93, 0x01, 0xd8, 0x03, 0xb2, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
                const dataNodeInfoNotificationNtf = new GW_GET_NODE_INFORMATION_NTF(dataNodeInfoNotification);

                const conn = new MockConnection(receivedFrames);
                const promProducts = Products.createProductsAsync(conn);
                for (const dataNodeNtf of dataNodesNtf) {
                    conn.sendNotification(dataNodeNtf, []);
                }
                // Send finished
                conn.sendNotification(dataNodeFinishNtf, []);
                const products = await promProducts;

                // Setups spies for counting notifications
                const productAddedSpy = sinon.spy();
                const productRemovedSpy = sinon.spy();
                products.onNewProduct((productID) => {
                    productAddedSpy(productID);
                });
                products.onRemovedProduct((productID) => {
                    productRemovedSpy(productID);
                });

                conn.sendNotification(dataNtf, [dataErrorNtf]);

                // Just let the asynchronous stuff run before our checks
                await new Promise(resolve => { setTimeout(resolve, 0); });

                expect(productAddedSpy.notCalled, `onNewProduct shouldn't be called at all. Instead it was called ${productAddedSpy.callCount} times.`).to.be.true;
                expect(productRemovedSpy.calledTwice, `onRemovedProduct should be called twice. Instead it was called ${productRemovedSpy.callCount} times.`).to.be.true;
            });
        });
    });
});
